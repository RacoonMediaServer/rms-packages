// Code generated by protoc-gen-micro. DO NOT EDIT.
// source: rms-library.proto

package rms_library

import (
	fmt "fmt"
	proto "google.golang.org/protobuf/proto"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	math "math"
)

import (
	context "context"
	api "go-micro.dev/v4/api"
	client "go-micro.dev/v4/client"
	server "go-micro.dev/v4/server"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Reference imports to suppress errors if they are not otherwise used.
var _ api.Endpoint
var _ context.Context
var _ client.Option
var _ server.Option

// Api Endpoints for Lists service

func NewListsEndpoints() []*api.Endpoint {
	return []*api.Endpoint{}
}

// Client API for Lists service

type ListsService interface {
	// добавление указанного тайтла в указанный список
	Add(ctx context.Context, in *ListsAddRequest, opts ...client.CallOption) (*emptypb.Empty, error)
	// перечислить элементы списка
	List(ctx context.Context, in *ListsListRequest, opts ...client.CallOption) (*ListsListResponse, error)
	// переместить тайтл в другой список
	Move(ctx context.Context, in *ListsMoveRequest, opts ...client.CallOption) (*emptypb.Empty, error)
	// удаление указанного тайтла из списка
	Delete(ctx context.Context, in *ListsDeleteRequest, opts ...client.CallOption) (*emptypb.Empty, error)
}

type listsService struct {
	c    client.Client
	name string
}

func NewListsService(name string, c client.Client) ListsService {
	return &listsService{
		c:    c,
		name: name,
	}
}

func (c *listsService) Add(ctx context.Context, in *ListsAddRequest, opts ...client.CallOption) (*emptypb.Empty, error) {
	req := c.c.NewRequest(c.name, "Lists.Add", in)
	out := new(emptypb.Empty)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *listsService) List(ctx context.Context, in *ListsListRequest, opts ...client.CallOption) (*ListsListResponse, error) {
	req := c.c.NewRequest(c.name, "Lists.List", in)
	out := new(ListsListResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *listsService) Move(ctx context.Context, in *ListsMoveRequest, opts ...client.CallOption) (*emptypb.Empty, error) {
	req := c.c.NewRequest(c.name, "Lists.Move", in)
	out := new(emptypb.Empty)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *listsService) Delete(ctx context.Context, in *ListsDeleteRequest, opts ...client.CallOption) (*emptypb.Empty, error) {
	req := c.c.NewRequest(c.name, "Lists.Delete", in)
	out := new(emptypb.Empty)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Lists service

type ListsHandler interface {
	// добавление указанного тайтла в указанный список
	Add(context.Context, *ListsAddRequest, *emptypb.Empty) error
	// перечислить элементы списка
	List(context.Context, *ListsListRequest, *ListsListResponse) error
	// переместить тайтл в другой список
	Move(context.Context, *ListsMoveRequest, *emptypb.Empty) error
	// удаление указанного тайтла из списка
	Delete(context.Context, *ListsDeleteRequest, *emptypb.Empty) error
}

func RegisterListsHandler(s server.Server, hdlr ListsHandler, opts ...server.HandlerOption) error {
	type lists interface {
		Add(ctx context.Context, in *ListsAddRequest, out *emptypb.Empty) error
		List(ctx context.Context, in *ListsListRequest, out *ListsListResponse) error
		Move(ctx context.Context, in *ListsMoveRequest, out *emptypb.Empty) error
		Delete(ctx context.Context, in *ListsDeleteRequest, out *emptypb.Empty) error
	}
	type Lists struct {
		lists
	}
	h := &listsHandler{hdlr}
	return s.Handle(s.NewHandler(&Lists{h}, opts...))
}

type listsHandler struct {
	ListsHandler
}

func (h *listsHandler) Add(ctx context.Context, in *ListsAddRequest, out *emptypb.Empty) error {
	return h.ListsHandler.Add(ctx, in, out)
}

func (h *listsHandler) List(ctx context.Context, in *ListsListRequest, out *ListsListResponse) error {
	return h.ListsHandler.List(ctx, in, out)
}

func (h *listsHandler) Move(ctx context.Context, in *ListsMoveRequest, out *emptypb.Empty) error {
	return h.ListsHandler.Move(ctx, in, out)
}

func (h *listsHandler) Delete(ctx context.Context, in *ListsDeleteRequest, out *emptypb.Empty) error {
	return h.ListsHandler.Delete(ctx, in, out)
}

// Api Endpoints for Torrents service

func NewTorrentsEndpoints() []*api.Endpoint {
	return []*api.Endpoint{}
}

// Client API for Torrents service

type TorrentsService interface {
	// получить список раздач, принадлежащих указанному тайтлу
	List(ctx context.Context, in *TorrentsListRequest, opts ...client.CallOption) (*TorrentsListResponse, error)
	// заменить указанную раздачу
	Replace(ctx context.Context, in *TorrentsReplaceRequest, opts ...client.CallOption) (*emptypb.Empty, error)
	// найти альтернативные варианты раздачи
	FindAlternatives(ctx context.Context, in *TorrentsFindAlternativesRequest, opts ...client.CallOption) (*TorrentsFindAlternativesResponse, error)
	// добавить раздачу к тайтлу
	Add(ctx context.Context, in *TorrentsAddRequest, opts ...client.CallOption) (*emptypb.Empty, error)
	// удалить раздачу
	Delete(ctx context.Context, in *TorrentsDeleteRequest, opts ...client.CallOption) (*emptypb.Empty, error)
}

type torrentsService struct {
	c    client.Client
	name string
}

func NewTorrentsService(name string, c client.Client) TorrentsService {
	return &torrentsService{
		c:    c,
		name: name,
	}
}

func (c *torrentsService) List(ctx context.Context, in *TorrentsListRequest, opts ...client.CallOption) (*TorrentsListResponse, error) {
	req := c.c.NewRequest(c.name, "Torrents.List", in)
	out := new(TorrentsListResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *torrentsService) Replace(ctx context.Context, in *TorrentsReplaceRequest, opts ...client.CallOption) (*emptypb.Empty, error) {
	req := c.c.NewRequest(c.name, "Torrents.Replace", in)
	out := new(emptypb.Empty)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *torrentsService) FindAlternatives(ctx context.Context, in *TorrentsFindAlternativesRequest, opts ...client.CallOption) (*TorrentsFindAlternativesResponse, error) {
	req := c.c.NewRequest(c.name, "Torrents.FindAlternatives", in)
	out := new(TorrentsFindAlternativesResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *torrentsService) Add(ctx context.Context, in *TorrentsAddRequest, opts ...client.CallOption) (*emptypb.Empty, error) {
	req := c.c.NewRequest(c.name, "Torrents.Add", in)
	out := new(emptypb.Empty)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *torrentsService) Delete(ctx context.Context, in *TorrentsDeleteRequest, opts ...client.CallOption) (*emptypb.Empty, error) {
	req := c.c.NewRequest(c.name, "Torrents.Delete", in)
	out := new(emptypb.Empty)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Torrents service

type TorrentsHandler interface {
	// получить список раздач, принадлежащих указанному тайтлу
	List(context.Context, *TorrentsListRequest, *TorrentsListResponse) error
	// заменить указанную раздачу
	Replace(context.Context, *TorrentsReplaceRequest, *emptypb.Empty) error
	// найти альтернативные варианты раздачи
	FindAlternatives(context.Context, *TorrentsFindAlternativesRequest, *TorrentsFindAlternativesResponse) error
	// добавить раздачу к тайтлу
	Add(context.Context, *TorrentsAddRequest, *emptypb.Empty) error
	// удалить раздачу
	Delete(context.Context, *TorrentsDeleteRequest, *emptypb.Empty) error
}

func RegisterTorrentsHandler(s server.Server, hdlr TorrentsHandler, opts ...server.HandlerOption) error {
	type torrents interface {
		List(ctx context.Context, in *TorrentsListRequest, out *TorrentsListResponse) error
		Replace(ctx context.Context, in *TorrentsReplaceRequest, out *emptypb.Empty) error
		FindAlternatives(ctx context.Context, in *TorrentsFindAlternativesRequest, out *TorrentsFindAlternativesResponse) error
		Add(ctx context.Context, in *TorrentsAddRequest, out *emptypb.Empty) error
		Delete(ctx context.Context, in *TorrentsDeleteRequest, out *emptypb.Empty) error
	}
	type Torrents struct {
		torrents
	}
	h := &torrentsHandler{hdlr}
	return s.Handle(s.NewHandler(&Torrents{h}, opts...))
}

type torrentsHandler struct {
	TorrentsHandler
}

func (h *torrentsHandler) List(ctx context.Context, in *TorrentsListRequest, out *TorrentsListResponse) error {
	return h.TorrentsHandler.List(ctx, in, out)
}

func (h *torrentsHandler) Replace(ctx context.Context, in *TorrentsReplaceRequest, out *emptypb.Empty) error {
	return h.TorrentsHandler.Replace(ctx, in, out)
}

func (h *torrentsHandler) FindAlternatives(ctx context.Context, in *TorrentsFindAlternativesRequest, out *TorrentsFindAlternativesResponse) error {
	return h.TorrentsHandler.FindAlternatives(ctx, in, out)
}

func (h *torrentsHandler) Add(ctx context.Context, in *TorrentsAddRequest, out *emptypb.Empty) error {
	return h.TorrentsHandler.Add(ctx, in, out)
}

func (h *torrentsHandler) Delete(ctx context.Context, in *TorrentsDeleteRequest, out *emptypb.Empty) error {
	return h.TorrentsHandler.Delete(ctx, in, out)
}

// Api Endpoints for Movies service

func NewMoviesEndpoints() []*api.Endpoint {
	return []*api.Endpoint{}
}

// Client API for Movies service

type MoviesService interface {
	// поиск информации о фильмах и сериалах во внешних источниках
	Search(ctx context.Context, in *MoviesSearchRequest, opts ...client.CallOption) (*MoviesSearchResponse, error)
	// получить инфу о фильме/сериале, присутствующем в библиотеке по его ID
	Get(ctx context.Context, in *MoviesGetRequest, opts ...client.CallOption) (*MoviesGetResponse, error)
	// получить список доступных новых сезонов для скачивания
	GetUpdates(ctx context.Context, in *emptypb.Empty, opts ...client.CallOption) (*MoviesGetUpdatesResponse, error)
}

type moviesService struct {
	c    client.Client
	name string
}

func NewMoviesService(name string, c client.Client) MoviesService {
	return &moviesService{
		c:    c,
		name: name,
	}
}

func (c *moviesService) Search(ctx context.Context, in *MoviesSearchRequest, opts ...client.CallOption) (*MoviesSearchResponse, error) {
	req := c.c.NewRequest(c.name, "Movies.Search", in)
	out := new(MoviesSearchResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *moviesService) Get(ctx context.Context, in *MoviesGetRequest, opts ...client.CallOption) (*MoviesGetResponse, error) {
	req := c.c.NewRequest(c.name, "Movies.Get", in)
	out := new(MoviesGetResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *moviesService) GetUpdates(ctx context.Context, in *emptypb.Empty, opts ...client.CallOption) (*MoviesGetUpdatesResponse, error) {
	req := c.c.NewRequest(c.name, "Movies.GetUpdates", in)
	out := new(MoviesGetUpdatesResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Movies service

type MoviesHandler interface {
	// поиск информации о фильмах и сериалах во внешних источниках
	Search(context.Context, *MoviesSearchRequest, *MoviesSearchResponse) error
	// получить инфу о фильме/сериале, присутствующем в библиотеке по его ID
	Get(context.Context, *MoviesGetRequest, *MoviesGetResponse) error
	// получить список доступных новых сезонов для скачивания
	GetUpdates(context.Context, *emptypb.Empty, *MoviesGetUpdatesResponse) error
}

func RegisterMoviesHandler(s server.Server, hdlr MoviesHandler, opts ...server.HandlerOption) error {
	type movies interface {
		Search(ctx context.Context, in *MoviesSearchRequest, out *MoviesSearchResponse) error
		Get(ctx context.Context, in *MoviesGetRequest, out *MoviesGetResponse) error
		GetUpdates(ctx context.Context, in *emptypb.Empty, out *MoviesGetUpdatesResponse) error
	}
	type Movies struct {
		movies
	}
	h := &moviesHandler{hdlr}
	return s.Handle(s.NewHandler(&Movies{h}, opts...))
}

type moviesHandler struct {
	MoviesHandler
}

func (h *moviesHandler) Search(ctx context.Context, in *MoviesSearchRequest, out *MoviesSearchResponse) error {
	return h.MoviesHandler.Search(ctx, in, out)
}

func (h *moviesHandler) Get(ctx context.Context, in *MoviesGetRequest, out *MoviesGetResponse) error {
	return h.MoviesHandler.Get(ctx, in, out)
}

func (h *moviesHandler) GetUpdates(ctx context.Context, in *emptypb.Empty, out *MoviesGetUpdatesResponse) error {
	return h.MoviesHandler.GetUpdates(ctx, in, out)
}

// Api Endpoints for Music service

func NewMusicEndpoints() []*api.Endpoint {
	return []*api.Endpoint{}
}

// Client API for Music service

type MusicService interface {
	// поиск информации о музыке во внешних источниках
	Search(ctx context.Context, in *MusicSearchRequest, opts ...client.CallOption) (*MusicSearchResponse, error)
	// получить список доступных новых сезонов для скачивания
	GetUpdates(ctx context.Context, in *emptypb.Empty, opts ...client.CallOption) (*MusicGetUpdatesResponse, error)
}

type musicService struct {
	c    client.Client
	name string
}

func NewMusicService(name string, c client.Client) MusicService {
	return &musicService{
		c:    c,
		name: name,
	}
}

func (c *musicService) Search(ctx context.Context, in *MusicSearchRequest, opts ...client.CallOption) (*MusicSearchResponse, error) {
	req := c.c.NewRequest(c.name, "Music.Search", in)
	out := new(MusicSearchResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *musicService) GetUpdates(ctx context.Context, in *emptypb.Empty, opts ...client.CallOption) (*MusicGetUpdatesResponse, error) {
	req := c.c.NewRequest(c.name, "Music.GetUpdates", in)
	out := new(MusicGetUpdatesResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Music service

type MusicHandler interface {
	// поиск информации о музыке во внешних источниках
	Search(context.Context, *MusicSearchRequest, *MusicSearchResponse) error
	// получить список доступных новых сезонов для скачивания
	GetUpdates(context.Context, *emptypb.Empty, *MusicGetUpdatesResponse) error
}

func RegisterMusicHandler(s server.Server, hdlr MusicHandler, opts ...server.HandlerOption) error {
	type music interface {
		Search(ctx context.Context, in *MusicSearchRequest, out *MusicSearchResponse) error
		GetUpdates(ctx context.Context, in *emptypb.Empty, out *MusicGetUpdatesResponse) error
	}
	type Music struct {
		music
	}
	h := &musicHandler{hdlr}
	return s.Handle(s.NewHandler(&Music{h}, opts...))
}

type musicHandler struct {
	MusicHandler
}

func (h *musicHandler) Search(ctx context.Context, in *MusicSearchRequest, out *MusicSearchResponse) error {
	return h.MusicHandler.Search(ctx, in, out)
}

func (h *musicHandler) GetUpdates(ctx context.Context, in *emptypb.Empty, out *MusicGetUpdatesResponse) error {
	return h.MusicHandler.GetUpdates(ctx, in, out)
}

// Api Endpoints for Other service

func NewOtherEndpoints() []*api.Endpoint {
	return []*api.Endpoint{}
}

// Client API for Other service

type OtherService interface {
	// поиск по торрентам
	Search(ctx context.Context, in *OtherSearchRequest, opts ...client.CallOption) (*OtherSearchResponse, error)
}

type otherService struct {
	c    client.Client
	name string
}

func NewOtherService(name string, c client.Client) OtherService {
	return &otherService{
		c:    c,
		name: name,
	}
}

func (c *otherService) Search(ctx context.Context, in *OtherSearchRequest, opts ...client.CallOption) (*OtherSearchResponse, error) {
	req := c.c.NewRequest(c.name, "Other.Search", in)
	out := new(OtherSearchResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Other service

type OtherHandler interface {
	// поиск по торрентам
	Search(context.Context, *OtherSearchRequest, *OtherSearchResponse) error
}

func RegisterOtherHandler(s server.Server, hdlr OtherHandler, opts ...server.HandlerOption) error {
	type other interface {
		Search(ctx context.Context, in *OtherSearchRequest, out *OtherSearchResponse) error
	}
	type Other struct {
		other
	}
	h := &otherHandler{hdlr}
	return s.Handle(s.NewHandler(&Other{h}, opts...))
}

type otherHandler struct {
	OtherHandler
}

func (h *otherHandler) Search(ctx context.Context, in *OtherSearchRequest, out *OtherSearchResponse) error {
	return h.OtherHandler.Search(ctx, in, out)
}
